// This schema defines the Protobuf messages used for communication with the
// Cube Order Service (Osmium, OS).
//
// ### Connection
//
// The order service exposes a websocket endpoint for clients to connect to.
// Once connected, clients should submit a [`Credentials`](#credentials)
// message, listen for [`Bootstrap`](#bootstrap) messages for resting orders
// and positions, and then can begin submitting
// [`OrderRequest`](#order-request) and processing
// [`OrderResponse`](#order-response).
//
// ### Heartbeats
//
// Application-level heartbeats are expected every 30 seconds. If more than one
// interval is missed, the order service will disconnect the websocket.
//
// ### Price, Quantity, and Lots
//
// All orders are placed on a single market, specified by the market-id. The
// market definition specifies the base and quote assets and their respective
// lot sizes for the particular market. Prices and quantities in this API are in
// units of base and quote _lots_. That is, a quantity of 1 equals 1 base lot,
// and a price of 10 equals 10 quote lots / base lot (read as quote lots per
// base lot).
//
// For example, consider an ETHBTC market. ETH is the base asset and BTC is the
// quote asset. ETH has 18 decimal places (`1 ETH = 10^18 WEI`) and BTC has 8
// decimal places (`1 BTC = 10^8 SAT`). Suppose that in this example, the ETHBTC
// market has a base lot size of `10^15` and a quote lot size of `10^0` (`1`).
// Then an order placed with `quantity = 230` and `price = 6300` in
// market-agnostic terms is an order for `0.23 ETH` at a price of `0.06300 BTC /
// ETH`. In more detail, we have:
//
// ```text
// 230 base lots
//   * (10^15 WEI / base lot)
//   / (10^18 WEI / ETH)
//   = 230 ETH
//
// 6300 quote lots / base lot
//   * (1 SAT / quote lot)
//   / (10^15 WEI / base lot)
//   * (10^18 WEI / ETH)
//   / (10^8 SAT / BTC)
//   = 0.06300 BTC / ETH
// ```
//
// ### Exchange Order ID
//
// Each order is assigned a unique ID by the exchange. This order ID is
// consistent across modifies (including cancel-replace), and other operations.
// The exchange order ID can be used to find a particular order in the
// market-by-order market data feed, which allows the determination of FIFO
// queue priority, etc.
//
// ### Transact Time
//
// The transact time is the matching engine timestamp for when an event is
// processed. Events that occur with the same transact time occur atomically
// from the perspective of the matching engine.
//
syntax = "proto3";

package trade;
option csharp_namespace = "Cube.Trade";
option go_package = "go/";

// Side specifies whether the order is buying or selling the base asset. A trade
// is matched when a buyer (BID) and a seller (ASK) agree on a price (cross).
// The bid-ask spread is the gap between the highest bid price and lowest ask
// price on the orderbook.
enum Side {
  // A bid order buys the base asset with the quote asset.
  BID = 0;
  // An ask (or offer) order sells the base asset and gets the quote asset.
  ASK = 1;
}

// Time-in-force (TIF) specifies how long the order remains in effect.
enum TimeInForce {
  // Immediate-or-cancel (IOC), also known as fill-and-kill (FAK), orders are
  // immediately executed against resting orders. If the order cannot be fully
  // filled, the remaining balance will be canceled, and an additional
  // CancelOrderAck with the IOC reason will be sent.
  IMMEDIATE_OR_CANCEL = 0;
  // Good-for-session (GFS) orders are active until they are completely
  // executed, canceled, or when the session expires.
  GOOD_FOR_SESSION = 1;
  // Fill-or-kill (FOK), also known as all-or-none (AON), orders must be filled
  // immediately against resting orders or the entire order is canceled.
  FILL_OR_KILL = 2;
}

// Order-type specifies how the order will be placed into the order book.
enum OrderType {
  // A limit order is accompanied with a price (inclusive) that specifies the
  // upper limit to buy and the lower limit to sell. If the price is not
  // immediately available and the TIF allows resting orders, the limit order
  // will rest until filled or canceled.
  LIMIT = 0;
  // A market limit order crosses the bid-ask spread and, if not fully filled,
  // becomes a limit order at the best available market price. If there is no
  // opposing market, the order is rejected with the NO_OPPOSING_LIMIT_ORDER
  // reason. Price must be null.
  MARKET_LIMIT = 1;
  // A market with protection order crosses the bid-ask spread and continues to
  // cross until the order is fully filled or the price protection level,
  // defined by the best market price widened by a market-specific protection
  // point count, is reached. If there is no opposing market, the order is
  // rejected with the NO_OPPOSING_LIMIT_ORDER reason. Price must be null.
  MARKET_WITH_PROTECTION = 2;
}

// Self-trade-prevention (STP) allows market participants to prevent the matching
// of orders for accounts with common ownership. Currently, STP only applies for
// orders with the same subaccount_id. STP will only be applied when a match is
// about to occur between the two orders. That is, if the aggressing order is
// fully filled before reaching the resting order in FIFO order, no STP cancels
// will happen.
enum SelfTradePrevention {
  // Cancel-resting specifies that if a self-trade is about to occur, the
  // resting order should be canceled instead and further order book processing
  // should occur as normal.
  CANCEL_RESTING = 0;
  // Cancel-aggressing specifies that if a self-trade is about to occur, the
  // aggressing order should be canceled instead and no further action should be
  // taken.
  CANCEL_AGGRESSING = 1;
  // Allow-self-trade disables STP functionality.
  ALLOW_SELF_TRADE = 2;
}

// Post-only specifies whether a new order is allowed to immediately execute.
// Post-only cannot be enabled with market orders or with a TIF that does not
// allow resting orders.
enum PostOnly {
  DISABLED = 0;
  ENABLED = 1;
}

// In general, order requests must have a signature attached to prove that the
// account owner was the one who issued the order request. Requests without
// valid signatures are rejected by the system. The signature version specifies
// how the parameters of the order request are encoded into a message over the
// signature will be computed. 
enum SignatureVersion {
  V0 = 0;
}

// Sent by client on websocket initialization. Once the websocket has been
// connected, the client is expected to send this credentials message
// immediately. The API key (UUID) and secret access key (hex-encoded 32-byte
// array) should be generated on the settings page with the write access. The
// signature should be calculated as the concatenation of the byte string
// `cube.xyz` and the current unix epoch in seconds interpreted at a
// little-endian 64-bit number. For example:
//
// ```rust compile_fail
// use hmac::{Hmac, Mac, NewMac};
// use std::time::SystemTime;
//
// let secret_key = [...];
//
// let timestamp = SystemTime::now()
//     .duration_since(SystemTime::UNIX_EPOCH)
//     .expect("clock went backwords")
//     .as_secs();
//
// let mut mac = Hmac::<sha2::Sha256>::new_from_slice(
//     secret_key
// ).expect("new HMAC error");
// mac.update(b"cube.xyz");
// mac.update(&timestamp.to_le_bytes());
// let signature = <[u8; 32]>::from(mac.finalize().into_bytes());
// ```
message Credentials {
  // Public API key
  string access_key_id = 1;
  // HMAC signature
  string signature = 2;
  // Timestamp in seconds
  uint64 timestamp = 3;
}


// Every client message, aside from Credentials, must be wrapped as an
// OrderRequest.
message OrderRequest {
  oneof inner {
    NewOrder new = 1;
    CancelOrder cancel = 2;
    ModifyOrder modify = 3;
    Heartbeat heartbeat = 4;
    MassCancel mc = 5;
  }
}

// Place a new order.
message NewOrder {
  // A unique order ID assigned by the client for this order. The ID must be
  // unique among open orders by this subaccount.
  uint64 client_order_id = 1;
  // A request ID that is echoed back on the NewOrderAck or NewOrderReject
  uint64 request_id = 2;
  uint64 market_id = 3;
  optional uint64 price = 4;
  uint64 quantity = 5;
  Side side = 6;
  TimeInForce time_in_force = 7;
  OrderType order_type = 8;
  // The subaccount to place this order on. This subaccount must be writable by
  // the API key specified in the Credentials message.
  uint64 subaccount_id = 9;
  optional SelfTradePrevention self_trade_prevention = 10;
  PostOnly post_only = 11;
  // The public key of the keypair used to sign this order request.
  bytes pubkey = 12;
  // The ed25519 signature over this order request.
  bytes signature = 13;
  SignatureVersion signatureVersion = 14;
}

// Cancel a resting order.
// Note that this can be done before the order is acknowledged (an aggressive
// cancel) since the identifying field is the `client_order_id`.
message CancelOrder {
  uint64 market_id = 1;
  // The order ID specified by the client on the NewOrder request.
  uint64 client_order_id = 2;
  // A request ID that is echoed back on the CancelOrderAck or CancelOrderReject
  uint64 request_id = 3;
  // The subaccount that the NewOrder was placed on.
  uint64 subaccount_id = 4;
  // The public key of the keypair used to sign this order request.
  bytes pubkey = 5;
  // The ed25519 signature over this order request.
  bytes signature = 6;
  SignatureVersion signatureVersion = 7;
}

// Modify a resting order.
// - If the `newPrice` and the current resting order's price is the same, and
// `newQuantity` is not greater, then the modify is considered a modify down,
// and the FIFO queue priority is maintained. Otherwise, the modify-order
// request is treated as an atomic cancel-replace and the replacement order is
// placed at the end of the FIFO queue for the new price level.
// - If post-only is specified and the replacement order would trade, then the
// request is rejected and the current resting order remains resting.
//
// Currently, in-flight-mitigation (IFM) is always enabled. That is, the
// cumulative fill qty is subtracted from `newQuantity` to calculate the new
// resting quantity. For example:
//
// ```text
//          | Resting | Filled
// ---------+---------+--------
// New 5    | 5       | 0
// Fill 2   | 3       | 2
// Modify 4 | 2       | 2
// ```
//
// The post-modify quantity will be `newQuantity - filled = 4 - 2 = 2`.
message ModifyOrder {
  uint64 market_id = 1;
  // The order ID specified by the client on the NewOrder request.
  uint64 client_order_id = 2;
  // A request ID that is echoed back on the ModifyOrderAck or ModifyOrderReject
  uint64 request_id = 3;
  uint64 new_price = 4;
  uint64 new_quantity = 5;
  // The subaccount that the NewOrder was placed on.
  uint64 subaccount_id = 6;
  optional SelfTradePrevention self_trade_prevention = 7;
  PostOnly post_only = 8;
  // The public key of the keypair used to sign this order request.
  bytes pubkey = 9;
  // The ed25519 signature over this order request.
  bytes signature = 10;
  SignatureVersion signatureVersion = 11;
}

// Cancel all resting orders, optionally limiting to a particular market and /
// or order book side.
message MassCancel {
  // The subaccount to cancel orders for.
  uint64 subaccount_id = 1;
  // A request ID that is echoed back on the MassCancelAck and individual
  // CancelOrderAck's.
  uint64 request_id = 2;
  // If specified, only orders on the corresponding market will be canceled.
  optional uint64 market_id = 3;
  // If specified, only orders with this side will be canceled.
  optional Side side = 4;
  // The public key of the keypair used to sign this order request.
  bytes pubkey = 5;
  // The ed25519 signature over this order request.
  bytes signature = 6;
  SignatureVersion signatureVersion = 7;
}

// A client and server heartbeat. The heartbeat reply, including the timestamp
// value, comes from the order service and not the matching engine. Matching
// engine timestamps can be extracted from `transact_time` (below).
//
// Latency can be estimated from this, but only the relative difference between
// successive server messages should be used. In particular, the client and
// server clock should not be expected to be synchronized.
message Heartbeat {
  // A request ID that is echoed back on the Heartbeat
  uint64 request_id = 1;
  uint64 timestamp = 2;
}



// Every exchange message after the initial bootstrap will be wrapped as an
// OrderResponse.
message OrderResponse {
  oneof inner {
    NewOrderAck new_ack = 1;
    CancelOrderAck cancel_ack = 2;
    ModifyOrderAck modify_ack = 3;
    NewOrderReject new_reject = 4;
    CancelOrderReject cancel_reject = 5;
    ModifyOrderReject modify_reject = 6;
    Fill fill = 7;
    Heartbeat heartbeat = 8;
    AssetPosition position = 9;
    MassCancelAck mass_cancel_ack = 10;
  }
}

// New-order-ack confirms a new-order request. The ack will be ordered before
// any fills for this order.
message NewOrderAck {
  uint64 msg_seq_num = 1;
  // The client order ID specified in the new-order request.
  uint64 client_order_id = 2;
  // The request ID specified in the new-order request.
  uint64 request_id = 3;
  // [Exchange order ID](#exchange-order-id)
  uint64 exchange_order_id = 4;
  uint64 market_id = 5;
  // If the order ultimately rests, the `price` field will include the resting
  // price.
  optional uint64 price = 6;
  // The quantity submitted in the new-order request.
  uint64 quantity = 7;
  Side side = 8;
  TimeInForce time_in_force = 9;
  OrderType order_type = 10;
  // [Transact time](#transact-time)
  uint64 transact_time = 11;
  uint64 subaccount_id = 12;
}

// Cancel-order-ack confirms a cancel request, or that an order has been
// canceled as the result of a different user-initiated reason.
message CancelOrderAck {
  enum Reason {
    UNCLASSIFIED = 0;
    DISCONNECT = 1;
    // This order was specified in a cancel request.
    REQUESTED = 2;
    // This was an IOC new-order that does not get fully filled.
    IOC = 3;
    // A resting order was STP canceled.
    STP_RESTING = 4;
    // An aggressing order was STP canceled.
    STP_AGGRESSING = 5;
    // This order was covered by a mass-cancel request.
    MASS_CANCEL = 6;
  }

  uint64 msg_seq_num = 1;
  uint64 client_order_id = 2;
  // If the Reason is `DISCONNECT`, `IOC`, `STP_RESTING`, or `STP_AGGRESSING`,
  // this request ID will be `u64::MAX`. Otherwise, it will be the request ID of
  // the initiated cancel action. For a mass cancel, each cancel order ack will
  // have the MassCancel's request_id.
  uint64 request_id = 3;
  // [Transact time](#transact-time)
  uint64 transact_time = 4;
  uint64 subaccount_id = 5;
  Reason reason = 6;
  uint64 market_id = 7;
}

// Modify-order-ack confirms a modify-order request. If the modify resulted in
// an aggressing cancel-replace, the ack will be ordered before any fills for
// this order.
message ModifyOrderAck {
  uint64 msg_seq_num = 1;
  uint64 client_order_id = 2;
  // The request ID specified in the modify request.
  uint64 request_id = 3;
  // [Transact time](#transact-time)
  uint64 transact_time = 4;

  // The quantity submitted in the modify request after applying IFM
  // logic.
  uint64 new_quantity = 5;
  uint64 subaccount_id = 6;
  uint64 market_id = 7;
  uint64 price = 8;
}

// Mass-cancel-ack confirms a mass-cancel request. If `reason` is set, the mass
// cancel was not applied and there are no affected orders. Individual
// CancelOrderAck's will be sent for each order that was affected.
message MassCancelAck {
  enum Reason {
    UNCLASSIFIED = 0;
    INVALID_MARKET_ID = 1;
    INVALID_SIDE = 2;
    INVALID_SIGNATURE_VERSION = 3;
    SIGNATURE_VERIFICATION_FAILED = 4;
  }

  uint64 msg_seq_num = 1;
  uint64 subaccount_id = 2;
  // The request ID specified in the mass-cancel request.
  uint64 request_id = 3;
  // [Transact time](#transact-time)
  uint64 transact_time = 4;
  optional Reason reason = 6;
  // The total number of orders that were canceled.
  uint32 total_affected_orders = 7;
}

// New-order-reject indicates that a new-order request was not applied.
message NewOrderReject {
  // Reasons that are prefixed with `INVALID_` normally indicate that the
  // corresponding field did not take a valid value.
  enum Reason {
    UNCLASSIFIED = 0;
    // Quantity was zero.
    INVALID_QUANTITY = 1;
    // The specified market ID does not exist.
    INVALID_MARKET_ID = 2;
    // The specified client order ID was not unique among open orders for this
    // subaccount.
    DUPLICATE_ORDER_ID = 3;
    INVALID_SIDE = 4;
    INVALID_TIME_IN_FORCE = 5;
    INVALID_ORDER_TYPE = 6;
    INVALID_POST_ONLY = 7;
    INVALID_SELF_TRADE_PREVENTION = 8;
    INVALID_SIGNATURE_VERSION = 9;
    // Internal error: the matching engine could not find this subaccounts
    // positions.
    UNKNOWN_TRADER = 10;
    PRICE_WITH_MARKET_ORDER = 11;
    POST_ONLY_WITH_MARKET_ORDER = 12;
    POST_ONLY_WITH_INVALID_TIF = 13;
    SIGNATURE_VERIFICATION_FAILED = 14;
    // The sum of open orders and this new-order would exceed the subaccounts
    // spot limits.
    EXCEEDED_SPOT_POSITION = 15;
    NO_OPPOSING_LIMIT_ORDER = 16;
    // The post-only order would have crossed and traded.
    POST_ONLY_WOULD_TRADE = 17;
    // A FOK was not fully fillable against resting orders at the requested
    // price and quantity.
    DID_NOT_FULLY_FILL = 18;
  }

  uint64 msg_seq_num = 1;
  // The client order ID specified in the new-order request.
  uint64 client_order_id = 2;
  // The request ID specified in the new-order request.
  uint64 request_id = 3;
  // [Transact time](#transact-time)
  uint64 transact_time = 4;
  uint64 subaccount_id = 5;
  Reason reason = 6;

  uint64 market_id = 7;
  optional uint64 price = 8;
  uint64 quantity = 9;
  Side side = 10;
  TimeInForce time_in_force = 11;
  OrderType order_type = 12;
}

// Cancel-order-reject indicates that a cancel-order request was not applied.
message CancelOrderReject {
  enum Reason {
    UNCLASSIFIED = 0;
    // The specified market ID does not exist.
    INVALID_MARKET_ID = 1;
    // The specified client order ID does not exist for the corresponding market
    // ID and subaccount ID.
    ORDER_NOT_FOUND = 2;
    INVALID_SIGNATURE_VERSION = 3;
    SIGNATURE_VERIFICATION_FAILED = 4;
  }

  uint64 msg_seq_num = 1;
  // The client order ID specified in the cancel-order request.
  uint64 client_order_id = 2;
  // The request ID specified in the cancel-order request.
  uint64 request_id = 3;
  // [Transact time](#transact-time)
  uint64 transact_time = 4;
  uint64 subaccount_id = 5;
  Reason reason = 6;
  uint64 market_id = 7;
}

// Modify-order-reject indicates that a modify-order request was not applied.
message ModifyOrderReject {
  // Reasons that are prefixed with `INVALID_` normally indicate that the
  // corresponding field did not take a valid value.
  enum Reason {
    UNCLASSIFIED = 0;
    // Quantity was zero.
    INVALID_QUANTITY = 1;
    // The specified market ID does not exist.
    INVALID_MARKET_ID = 2;
    // The specified client order ID does not exist for the corresponding market
    // ID and subaccount ID.
    ORDER_NOT_FOUND = 3;
    INVALID_IFM = 4;
    INVALID_POST_ONLY = 5;
    INVALID_SELF_TRADE_PREVENTION = 6;
    INVALID_SIGNATURE_VERSION = 7;
    // Internal error: the matching engine could not find this subaccounts
    // positions.
    UNKNOWN_TRADER = 8;
    SIGNATURE_VERIFICATION_FAILED = 9;
    // If the modify-order would cause a cancel-replace, the sum of open orders
    // and this replacement order would exceed the subaccounts spot limits.
    EXCEEDED_SPOT_POSITION = 10;
    // If the modify-order would cause a cancel-replace, the post-only
    // replacement would have crossed and traded.
    POST_ONLY_WOULD_TRADE = 11;
  }

  uint64 msg_seq_num = 1;
  // The client order ID specified in the modify-order request.
  uint64 client_order_id = 2;
  // The request ID specified in the modify-order request.
  uint64 request_id = 3;
  // [Transact time](#transact-time)
  uint64 transact_time = 4;
  uint64 subaccount_id = 5;
  Reason reason = 6;
  uint64 market_id = 7;
}

// A fill for an order.
message Fill {
  uint64 msg_seq_num = 1;
  uint64 market_id = 2;
  // The client order ID specified in the new-order request.
  uint64 client_order_id = 3;
  // [Exchange order ID](#exchange-order-id)
  uint64 exchange_order_id = 4;
  // The price that this trade occured at.
  uint64 fill_price = 5;
  // The quantity that was traded in this fill.
  uint64 fill_quantity = 6;
  // The remaining quantity for this order after the fill is applied.
  uint64 leaves_quantity = 7;
  // [Transact time](#transact-time)
  uint64 transact_time = 8;
  uint64 subaccount_id = 9;
}

// The user's underlying asset position. These are sent asynchronously as
// positions are updated and broadcast through internal position channels. They
// can also be tracked by applying other OrderResponse messages individually.
message AssetPosition {
  uint64 subaccount_id = 1;
  uint64 asset_id = 2;
  RawUnits total = 3;
  // The available amount after open orders are subtracted.
  RawUnits available = 4;
}

// Raw-units is a 256-bit number for the amount of an asset. The precision is
// based on the underlying asset. For example, ETH is specified as if in
// fixed-point 10^18, while BTC is specified as if in fixed-point 10^8.
//
// The number is interpreted in 'little-endian' as `[word0, word1, word2,
// word3]`.
message RawUnits {
  uint64 word0 = 1;
  uint64 word1 = 2;
  uint64 word2 = 3;
  uint64 word3 = 4;
}


// A bootstrap message sent after Credentials authentication.
// Client resting and pending orders used to bootstrap state. Sent as the first
// message(s) after initialization. Bootstrap is complete after a message tagged
// `Done` is received and every message after that will be an `OrderResponse`.
// Multiple messages may be received for `RestingOrders` and `AssetPositions`
// and these should be concatenated.
message Bootstrap {
  oneof inner {
    Done done = 1;
    RestingOrders resting = 2;
    AssetPositions position = 3;
  }
}

// A chunk of resting orders. Sent on bootstrap.
message RestingOrders {
  repeated RestingOrder orders = 1;
}

// A chunk of asset positions. Sent on bootstrap.
message AssetPositions {
  repeated AssetPosition positions = 1;
}

// An indication that bootstrap is complete.
message Done {
  // [Transact time](#transact-time)
  uint64 latest_transact_time = 1;
}

// A resting order. Sent on bootstrap in `RestingOrders`.
message RestingOrder {
  // The client order ID specified in the new-order request.
  uint64 client_order_id = 1;
  // [Exchange order ID](#exchange-order-id)
  uint64 exchange_order_id = 2;
  uint64 market_id = 3;
  uint64 price = 4;
  // The quantity submitted in the new-order request.
  uint64 original_quantity = 5;
  Side side = 6;
  TimeInForce time_in_force = 7;
  OrderType order_type = 8;

  // The current remaining quantity on the book.
  uint64 remaining_quantity = 9;

  // [Transact time](#transact-time) of the NewOrderAck
  uint64 rest_time = 10;
  uint64 subaccount_id = 11;
}
